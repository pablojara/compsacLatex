\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[T1]{fontenc}
\usepackage[noend]{algpseudocode}
\newcommand{\algmargin}{\the\ALG@thistlm}
\makeatother
\newlength{\whilewidth}
\settowidth{\whilewidth}{\algorithmicwhile\ }
\algdef{SE}[parWHILE]{parWhile}{EndparWhile}[1]
  {\parbox[t]{\dimexpr\linewidth-\algmargin}{%
     \hangindent\whilewidth\strut\algorithmicwhile\ #1\ \algorithmicdo\strut}}{\algorithmicend\ \algorithmicwhile}%
\algnewcommand{\parState}[1]{\State%
  \parbox[t]{\dimexpr\linewidth-\algmargin}{\strut #1\strut}}
\algdef{SE}[parIF]{parIf}{EndParIf}[1]
  {\parbox[t]{\dimexpr\linewidth-\algmargin}{%
     \hangindent\whilewidth\strut\algorithmicwhile\ #1\ \algorithmicdo\strut}}{\algorithmicend\ \algorithmicwhile}%

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{document}
\begin{algorithm}

\caption{Network Aware Scheduler}\label{Kubernetes}
\begin{algorithmic}[1]
\Function{calculatePriorities}{}
\State Let $nodeMetrics[i].cpu$ be
\State Let $bestRecPackets$ be

\For{\textit{int i = 0; i < 4; i++}}
\If {$\textit nodeMetrics[i].cpu < bestCpu$}
\State $\textit bestCpu \gets nodeMetrics[i].cpu[i]$
\State $\textit bestCpuN \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].mem < bestMem$}
\State $\textit bestMem \gets nodeMetrics[i].mem[i]$
\State $\textit bestMemN \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].recPck < bestRecPck$}
\State $\textit bestRecPck \gets nodeMetrics[i].recPck[i]$
\State $\textit bestRecPckN \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].sentPck < bestSentPck$}
\State $\textit bestSentPck \gets nodeMetrics[i].sentPck[i]$
\State $\textit bestSentPckN \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].bwidth > bestBwidth$}
\State $\textit bestBwidth \gets nodeMetrics[i].bwidth[i]$
\State $\textit bestBwidthN \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].diskIO < bestDiskIO$}
\State $\textit bestDiskIO \gets nodeMetrics[i].diskIO[i]$
\State $\textit bestDiskION \gets nodeMetrics[i].name$
\EndIf
\EndFor
\BState
\State $\textit nodePriorities[bestCpuN]+=3$
\State $\textit nodePriorities[bestMemN]+=2$
\State $\textit nodePriorities[bestRecPckN]+=1$
\State $\textit nodePriorities[bestSentPckN]+=1$
\State $\textit nodePriorities[bestBwithN]+=2$
\State $\textit nodePriorities[bestDiskION]+=1$
\BState
\State \textbf{return} $nodePriorities$
\EndFunction
\end{algorithmic}

\end{algorithm}
\end{document}
