\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[T1]{fontenc}
\usepackage[noend]{algpseudocode}
\newcommand{\algmargin}{\the\ALG@thistlm}
\makeatother
\newlength{\whilewidth}
\settowidth{\whilewidth}{\algorithmicwhile\ }
\algdef{SE}[parWHILE]{parWhile}{EndparWhile}[1]
  {\parbox[t]{\dimexpr\linewidth-\algmargin}{%
     \hangindent\whilewidth\strut\algorithmicwhile\ #1\ \algorithmicdo\strut}}{\algorithmicend\ \algorithmicwhile}%
\algnewcommand{\parState}[1]{\State%
  \parbox[t]{\dimexpr\linewidth-\algmargin}{\strut #1\strut}}
\algdef{SE}[parIF]{parIf}{EndParIf}[1]
  {\parbox[t]{\dimexpr\linewidth-\algmargin}{%
     \hangindent\whilewidth\strut\algorithmicwhile\ #1\ \algorithmicdo\strut}}{\algorithmicend\ \algorithmicwhile}%

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{document}
\begin{algorithm}
\caption{Custom Scheduler}\label{Kubernetes}
\begin{algorithmic}[1]
\Function{calculatePriorities}{}
\State $\textit nodeMetrics[0] \gets {getNodeMetrics}(raspiWorker0)$
\State $\textit nodeMetrics[1] \gets {getNodeMetrics}(raspiWorker1)$
\State $\textit nodeMetrics[2] \gets {getNodeMetrics}(raspiWorker2)$
\State $\textit nodeMetrics[3] \gets {getNodeMetrics}(raspiWorker3)$
\BState 
\For{\textit{int i = 0; i < 4; i++}}
\If {$\textit nodeMetrics[i].cpu < bestCpu$}
\State $\textit bestCpu \gets nodeMetrics[i].cpu[i]$
\State $\textit bestCpuNode \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].memory < bestMemory$}
\State $\textit bestMemory \gets nodeMetrics[i].memory[i]$
\State $\textit bestMemoryNode \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].recPackets < bestRecPackets$}
\State $\textit bestRecPackets \gets nodeMetrics[i].recPackets[i]$
\State $\textit bestRecPacketsNode \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].sentPackets < bestSentPackets$}
\State $\textit bestSentPackets \gets nodeMetrics[i].sentPackets[i]$
\State $\textit bestSentPacketsNode \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].bandwidth > bestBandwidth$}
\State $\textit bestBandwidth \gets nodeMetrics[i].bandwidth[i]$
\State $\textit bestBandwidthNode \gets nodeMetrics[i].name$
\EndIf
\If {$\textit nodeMetrics[i].diskIO < bestDiskIO$}
\State $\textit bestDiskIO \gets nodeMetrics[i].diskIO[i]$
\State $\textit bestDiskIONode \gets nodeMetrics[i].name$
\EndIf
\EndFor
\BState
\State $\textit nodePriorities[bestCpuNode]+=3$
\State $\textit nodePriorities[bestMemoryNode]+=2$
\State $\textit nodePriorities[bestRecPacketsNode]+=1$
\State $\textit nodePriorities[bestSentPacketsNode]+=1$
\State $\textit nodePriorities[bestBandwidthNode]+=2$
\State $\textit nodePriorities[bestDiskIONode]+=1$
\BState
\State \textbf{return} $nodePriorities$
\EndFunction
\end{algorithmic}
\end{algorithm}
\end{document}